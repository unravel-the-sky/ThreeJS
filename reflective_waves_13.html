<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>New ideas in ThreeJS - Base</title>
		<style>
			body { 
        margin: 0; 
        overflow: hidden; 
        background: #FFFFFF;
        background: -moz-radial-gradient(center, circle cover,  #ffffff 10%, #e5e5e5 100%); /* FF3.6+ */
        background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(10%,#ffffff), color-stop(100%,#e5e5e5)); /* Chrome,Safari4+ */
        background: -webkit-radial-gradient(center, circle cover,  #ffffff 10%,#e5e5e5 100%); /* Chrome10+,Safari5.1+ */
        background: -o-radial-gradient(center, circle cover,  #ffffff 10%,#e5e5e5 100%); /* Opera 12+ */
        background: -ms-radial-gradient(center, circle cover,  #ffffff 10%,#e5e5e5 100%); /* IE10+ */
        background: radial-gradient(circle at center,  #ffffff 10%,#e5e5e5 100%); /* W3C */
			}
			canvas { width: 100%; height: 100% }
		</style>
	</head>
  
	<body>
		<script src="js/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/loaders/OBJLoader.js"></script>
    <script src="js/loaders/BinaryLoader.js"></script>
    <script src="js/MarchingCubes.js"></script>
    <script src="js/libs/stats.min.js"></script>
  
    
    <script type="x-shader/x-vertex" id="vertexShader">
      #ifdef GL_ES
      precision highp float;
      #endif
      
      uniform float time;
      
      varying vec2 vUv;
      varying vec3 vNormal;
      varying vec3 vPosition;

      varying float scaledTime;
      
      //Fresnel stuff
      varying vec3 vPositionW;
      varying vec3 vNormalW;

      //Environmental map stuff
      varying vec2 vN;
      
      void main(){
      
        vUv = uv;

        vec3 vertex = position;
        //vertex.x += sin (2.0 + position.y + (time)) * 1.9;
        //vertex.y += cos (2.0 + position.y + (time)) * 1.2;
        //vertex.x += sin (2.0 + position.y + (time)) * 0.01 * cos (10.0 + position.y + (time)) * 0.9;
        vertex.y += cos (2.0 + position.y + (time)) * 1.2 + (sin(time) + cos(time)) * 1.5;
        vertex.z += cos (2.0 + position.y + (time)) * 0.2 + sin(time) * 0.0;

        vec4 p = vec4(vertex, 1.0);
        vec3 e = normalize(vec3(modelViewMatrix * p));
        vec3 n = normalize(normalMatrix * normal);

        vec3 r = reflect(e,n);
        float m = 2.0 * sqrt(pow(r.x, 2.0) + pow(r.y, 2.0) + pow(r.z + 1.0, 2.0));

        vN = r.xy / m + 0.5;
        
        vec4 mvPosition = modelViewMatrix * p;
        //vec4 mvPosition = modelViewMatrix * vec4(vertex, 1.0);

        vPosition = position;
        vNormal = normal;
        
        //Fresnel ziki
        //vec4 outPosition = worldViewProjection * vec4(position, 1.0);
        vPositionW = vec3(modelMatrix * vec4(position, 1.0));
        vNormalW = normalize(vec3(modelMatrix * vec4(normal, 0.0)));

        //vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); //old logic
          
        gl_Position = projectionMatrix * mvPosition;

        scaledTime =  sin( time )+ 1.5; // zhis i found on the 'internet'
        
      }
        
    </script>

	<script type="x-shader/x-vertex" id="vertexShader_2">
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform float time;

      varying vec2 vUv;
      varying vec3 vNormal;
      varying vec3 vPosition;

      varying float scaledTime;

      //Fresnel stuff
      varying vec3 vPositionW;
      varying vec3 vNormalW;

      //Environmental map stuff
      varying vec2 vN;

      void main(){
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script type="x-shader/x-vertex" id="vertexShader_Wave">
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform float time;
      
      uniform float x_coord;
      uniform float y_coord;
      uniform float magnitude;
      uniform float size;

      varying vec2 vUv;

      //Fresnel stuff
      varying vec3 vPositionW;
      varying vec3 vNormalW;
      varying float x_pos_light;
      varying float y_pos_light;

      //Environmental map stuff
      varying vec2 vN;

      //shadowsss
      varying vec3 vWorldPosition;

      void main(){
        vUv = uv;
        x_pos_light = x_coord;
        y_pos_light = y_coord;

        //Fresnel ziki
        vPositionW = vec3(modelMatrix * vec4(position, 1.0));
        vNormalW = normalize(vec3(modelMatrix * vec4(normal, 0.0)));
        
        float x_coord_comp = sin( x_coord )+ 1.5;
        //vec2 center = vec2(100.0, 0.0);
        vec2 center = vec2(x_coord, y_coord);
        vec3 vertex = position;
        vec2 distance = vec2(vertex.x, vertex.y) - center;
        //float size = 5.0;
        //float magnitude = 4.0;

        float multiplier = 1.0 * (sin(time + 3.5));

        float length = length(distance);

        vertex.z += sin(length/1.0 / -size + time) * magnitude;

        //environmental stuff
        vec4 p = vec4(vertex, 1.0);
        vec3 e = normalize(vec3(modelViewMatrix * p));
        vec3 n = normalize(normalMatrix * normal);

        vec3 r = reflect(e,n);
        float m = 2.0 * sqrt(pow(r.x, 2.0) + pow(r.y, 2.0) + pow(r.z + 1.0, 2.0));

        vN = r.xy / m + 0.5;
        
        vWorldPosition = (modelViewMatrix * vec4(vertex, 1.0)).xyz;
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);
      }
    </script>
    
    <script type="x-shader/x-fragment" id="fragmentShader">
    
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform sampler2D tMatCap; //bu dosyadan gelcek
      
      varying vec2 vUv;
      //Fresnel stuff
      varying vec3 vPositionW;
      varying vec3 vNormalW;

      //Environmental map stuff
      varying vec2 vN;

      varying float scaledTime;

      //shadowsss
      varying vec3 vWorldPosition;
      
      void main(){

        vec3 viewDirectionW = normalize(cameraPosition - vWorldPosition);


        vec3 vLightPosition_1 = vec3(50, 90, -90);
        vec3 lightVectorW_1 = normalize(vLightPosition_1 - vWorldPosition);

        vec3 vLightPosition_2 = vec3(-40, 90, 90);
        //vec3 vLightPosition_2_moving = vec3(vLightPosition_2.x * scaledTime, vLightPosition_2.y * scaledTime, vLightPosition_2.z * scaledTime);
        vec3 lightVectorW_2 = normalize(vLightPosition_2 - vWorldPosition);

        vec3 color = vec3(1.0, 0.0, 1.0); //make this an input later on

        //calculate diffuse light
        float diffuseLight = max(0.0, dot(vNormalW, lightVectorW_1)) + 0.2;

        //calculate specular light
        vec3 angleW = normalize(viewDirectionW + lightVectorW_1);
        float specularComponent = max(0.0, dot(vNormalW, angleW));
        specularComponent = pow(specularComponent, max(1.0, 64.0)) * 0.8;

        //finally Fresnel
        float fresnelTerm = dot(viewDirectionW, vNormalW);
        fresnelTerm = clamp(1.0 - fresnelTerm, 0.0, 1.0) * 0.0 + 1.0;
      
        vec3 base = texture2D(tMatCap, vN).rgb;  

        //some cool Colorify Shader --http://threejs.org/examples/js/shaders/ColorifyShader.js
        vec3 luma = vec3(0.9, 0.587, 0.114);
        float v = dot(base.xyz, luma);

        //gl_FragColor = vec4(base * fresnelTerm * diffuseLight + vec3(specularComponent), 1.0);
        gl_FragColor = vec4(base * v * fresnelTerm * diffuseLight + vec3(specularComponent), 0.5);
        //gl_FragColor = vec4(vec3(vUv, 0.0), 1.0);
        //gl_FragColor = vec4(vec3(vUv, 0.0) * fresnelTerm * diffuseLight + vec3(specularComponent), 1.0);
      
      }
    
    </script>

	<script type="x-shader/x-fragment" id="dotScreenShader">

    #ifdef GL_ES
    precision highp float;
    #endif
    //taken from http://threejs.org/examples/js/shaders/DotScreenShader.js

    uniform sampler2D tMatCap; //bu dosyadan gelcek

    varying vec2 vUv;
      
    uniform vec2 center;
    uniform float angle;
    uniform float scale;
    uniform vec2 tSize;
    
    float pattern() {
			float s = sin( angle );
			float c = cos( angle );

			float newScale = sin(scale * 2.1) + cos(scale * 3.2) + sin(scale * 4.3);

			vec2 tex = vUv * tSize - center;
			vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * newScale;

			return ( sin( point.x ) * sin( point.y ) ) * 4.0;
		}
		
		void main(){
			vec4 color = texture2D(tMatCap, vUv);
			float average = (color.r + color.g + color.b) / 3.0;

			float newColor = abs(sin(scale * 2.1) + cos(scale * 3.2) + sin(scale * 4.3));
			
			gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern(), newColor, newColor), 0.4);
    }

  </script>

  <script type="x-shader/x-fragment" id="fragmentShader_base">

    #ifdef GL_ES
    precision highp float;
    #endif

    uniform sampler2D tMatCap; //bu dosyadan gelcek

    varying vec2 vUv;
    varying float x_pos_light;
    varying float y_pos_light;

    //Fresnel stuff
    varying vec3 vPositionW;
    varying vec3 vNormalW;

    uniform vec2 center;
    uniform float angle;
    uniform float scale;
    uniform vec2 tSize;

    void main(){

      vec3 viewDirectionW = normalize(cameraPosition - vPositionW);

      vec3 vLightPosition_1 = vec3(30, 40, 20);
      vec3 lightVectorW_1 = normalize(vLightPosition_1 - vPositionW);

      vec3 color = vec3(1.0, 0.0, 1.0); //make this an input later on

      //calculate diffuse light
      float diffuseLight = max(0.0, dot(vNormalW, lightVectorW_1)) + 0.2;

      //calculate specular light
      vec3 angleW = normalize(viewDirectionW + lightVectorW_1);
      float specularComponent = max(0.0, dot(vNormalW, angleW));
      specularComponent = pow(specularComponent, max(1.0, 64.0)) * 0.8;

      gl_FragColor = vec4(diffuseLight * vec3(vUv, 0.5) + vec3(specularComponent), 1.0);
    }

  </script>

	<script>
		// Our Javascript will go here.
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
    var controls; // controls stuff

    var position3d = new THREE.Vector3(0.0, 0.0, 0.0);
    var mouseX = 0.0;
    var mouseY = 0.0;

    var line;

    var stats;

    var renderer = new THREE.WebGLRenderer({ antialias: true }, { alpha: false });
    renderer.setClearColor(0xffffff, 0.7);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

		document.body.appendChild(renderer.domElement);


		document.addEventListener('mousemove', onDocumentMouseMove, false);
		document.addEventListener('click', onDocumentMouseClick, false);
		window.addEventListener('resize', onWindowResize, false);

		stats = new Stats();
		stats.domElement.style.position = 'absolute'
		stats.domElement.style.left = '0px'
		stats.domElement.style.top = '600px'
		document.body.appendChild(stats.domElement);
      
      
    var sphereGeometry = new THREE.SphereGeometry( 15, 50, 50 );
    var cubeGeometry = new THREE.BoxGeometry( 50, 10, 10, 65, 65 );
      
    var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
    var shaderMaterial = new THREE.ShaderMaterial ({
      uniforms: {
        time: { value: 0.1 },
        tMatCap: {
          type: 't',
          value: THREE.ImageUtils.loadTexture('files/blood.jpg')
        },
      },
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent,
      side: THREE.FrontSide,
      blending: THREE.MultiplyBlending, //this could be changed
    });

    var shaderMaterial_ScreenShader = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0.1 },
        tMatCap: {
          type: 't',
          value: THREE.ImageUtils.loadTexture('files/hamster.jpg')
        },
        tSize: { value: new THREE.Vector2(256, 256) },
        center: { value: new THREE.Vector2(0.5, 0.5) },
        angle: { value: 1.57 },
				scale: {value: 1.0}
      },
      vertexShader: document.getElementById('vertexShader_2').textContent,
      fragmentShader: document.getElementById('dotScreenShader').textContent,
      side: THREE.FrontSide,
      blending: THREE.MultiplyBlending, //this could be changed
      transparent: true
    });

    var shaderMaterial_Waves = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0.1 },
        x_coord: { value: 50.0 },
        y_coord: { value: 50.0 },
        magnitude: { value: 6.0 },
        size: { value: 5.0 },
        tMatCap: {
          type: 't',
          value: THREE.ImageUtils.loadTexture('files/matcap.jpg')
        }
      },
      vertexShader: document.getElementById('vertexShader_Wave').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent,
      side: THREE.DoubleSide,
      blending: THREE.MultiplyBlending, //this could be changed
      //transparent: true
    });

    //var materialSphere = new THREE.MeshLambertMaterial(color = "#ff0000");


    var parentObject3d = new THREE.Object3D();

    var lineGeometry = new THREE.Geometry();
    lineGeometry.vertices.push(new THREE.Vector3(0, -10, 0));
    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0));
    lineGeometry.vertices.push(new THREE.Vector3(0, 10, 0));

    var lineMaterial = new THREE.LineBasicMaterial({color: 0x0000ff});

    line = new THREE.Line(lineGeometry, lineMaterial);

    //scene.add(line);

    var ambient = new THREE.AmbientLight(0x444444);
    scene.add(ambient);

    var spotLight = new THREE.SpotLight(0xFFAA88);
    spotLight.position.y = 100;
    spotLight.position.x = 100;
    spotLight.target.position.set(10, 200, 0);
    spotLight.shadow.camera.near = 0.01;
    spotLight.castShadow = true;
    //spotLight.shadowCameraVisible = true;

    scene.add(spotLight);

    var light = new THREE.DirectionalLight(0x4444cc, 2);
    light.position.set(1, 4, 1).normalize();
    light.castShadow = true;
    light.shadow.camera.near = 1;
    light.shadow.camera.far = 30;
    scene.add(light);
      
    var sphere = new THREE.Mesh(cubeGeometry, shaderMaterial_Waves);
    sphere.geometry.dynamic = true;
    sphere.rotation.x += -0.5 * Math.PI;

    var sphere2 = new THREE.Mesh(sphereGeometry, shaderMaterial_Waves);
    sphere2.geometry.dynamic = true;
    sphere2.rotation.x += -0.5 * Math.PI;

    //var geometry_copy = new THREE.Geometry();
    //geometry_copy.copy(THREE.SphereGeometry(15, 165, 165));

    var sphereGeometry2 = new THREE.SphereGeometry(15, 165, 165);

    var sphere3 = new THREE.Mesh(sphereGeometry2, shaderMaterial_Waves);
    sphere3.geometry.dynamic = true;
    sphere3.rotation.x += -0.5 * Math.PI;

    var vertexIndex = 0;

    for (var i = 0; i < sphere.geometry.vertices.length ; i++) {
      sphere.geometry.vertices[i].x += 10;
      sphere.geometry.vertices[i].y += 10;
    }

    for (var i = 0; i < sphere2.geometry.vertices.length ; i++) {
      sphere2.geometry.vertices[i].x += 10;
      sphere2.geometry.vertices[i].y += 50;
    }

    for (var i = 0; i < sphere3.geometry.vertices.length ; i++) {
      sphere3.geometry.vertices[i].x += 20;
      sphere3.geometry.vertices[i].y += -10;
    }

    var num_rows = 8;
    var num_points = num_rows * num_rows;
    var x = 0;
    var y = 0;
    var z = 0;

    for (var i = 0; i < num_points; i++) {
      if (i % num_rows == 0 && y != 0)
        x++;

      var cubeGeometryAuto = new THREE.BoxGeometry(6, 6, 6, 15, 15);
      var sphereGeometryAuto = new THREE.SphereGeometry(4, 25, 25);
      var cubeAuto = new THREE.Mesh(sphereGeometryAuto, shaderMaterial_Waves);
      cubeAuto.geometry.dynamic = true;
      //cubeAuto.rotation.x += -0.5 * Math.PI;

      var random = Math.random();
      for (var j = 0; j < cubeAuto.geometry.vertices.length ; j++) {
        cubeAuto.geometry.vertices[j].x += ((y * 10) % (num_rows * 10));
        cubeAuto.geometry.vertices[j].y += x * 10;
        //cubeAuto.geometry.vertices[j].z += z * num_rows * 10 % (num_rows);
        cubeAuto.castShadow = true;
        cubeAuto.geometry.verticesNeedUpdate = true;
        cubeAuto.updateMatrixWorld();
      }

      cubeAuto.frustumCulled = false;
      parentObject3d.add(cubeAuto);
      y++; z++;
    }

    //parentObject3d.add(sphere);
    //parentObject3d.add(sphere2);
    //parentObject3d.add(sphere3);


    //scene.add(sphere2);
    parentObject3d.rotation.x += 0.5 * Math.PI;

    //parentObject3d.position.x = 10;
    //parentObject3d.position.y = 100;
    //parentObject3d.position.z = 100;

    //sphere.position.x = 20;
    parentObject3d.updateMatrix();
    scene.add(parentObject3d);

    var newMaterial = new THREE.MeshPhongMaterial({ color: "#ff0000", transparent: true, opacity: 0.2 });
    var cube = new THREE.Mesh(cubeGeometry, shaderMaterial_ScreenShader);
    cube.geometry.dynamic = true;
    cube.position.x = 0;
    cube.position.y = 2;
    cube.position.z = 1;
    //scene.add(cube);

    var manager = new THREE.LoadingManager();
    manager.onProgress = function (item, loaded, total) {

      console.log(item, loaded, total);

    };

    var texture = new THREE.Texture();

    var onProgress = function (xhr) {
      if (xhr.lengthComputable) {
        var percentComplete = xhr.loaded / xhr.total * 100;
        console.log(Math.round(percentComplete, 2) + '% downloaded');
      }
    };

    var onError = function (xhr) {
    };

    var parentObject = new THREE.Object3D();

    var loader = new THREE.ObjectLoader(manager);
    loader.load('files/skull.json',
      function (object) {
        object.traverse(function (child) {
        	if (child instanceof THREE.Mesh) {
        	  child.material = shaderMaterial;
        	  child.position.z = 40;
        	  child.scale.x = 3;
        	  child.scale.y = 3;
        	  child.scale.z = 3;
        	}
        });
        parentObject.add(object);
        //scene.add(object);
      },
      onProgress, onError);

    camera.position.x = 134;
    camera.position.y = 100;
    camera.position.z = 121;

    // cool STUFF coming here
    var planeGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
    //var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

    var cubeGeometryPlane = new THREE.CubeGeometry(100, 0.2, 100);

    var planeMaterial = new THREE.MeshPhongMaterial({
      ambient: 0x444444,
      color: 0x66aa66,
      shininess: 150,
      specular: 0x888888,
      shading: THREE.SmoothShading,
    });

    var plane = new THREE.Mesh(cubeGeometryPlane, planeMaterial);
    plane.geometry.verticesNeedUpdate = true;

    //plane.rotation.x = -0.5 * Math.PI;

    //plane.position.x = 20;
    plane.position.y = -20;

    plane.castShadow = false;
    plane.receiveShadow = true;

    scene.add(plane);

    var dummySphere = new THREE.Mesh(new THREE.SphereGeometry(10, 25, 25), shaderMaterial_Waves);
    dummySphere.castShadow = true;
    dummySphere.receiveShadow = true;
    scene.add(dummySphere);

    var wireframeHelper = new THREE.WireframeHelper(plane, 0x000000);
    wireframeHelper.material = shaderMaterial_Waves;
    wireframeHelper.material.linewidth = 2;
    //scene.add(wireframeHelper);

    //MARCHING CUBES DA FAQ
    var resolution = 50;
    var numBlobs = 20;

    var effect = new THREE.MarchingCubes(resolution, material, true, false);
    effect.scale.set(100, 100, 100);

    //scene.add(effect);

    function onDocumentMouseMove(event) {
      //var windowHalfX = window.innerWidth / 2;
      //var windowHalfY = window.innerHeight / 2;
      //mouseX = (event.clientX - windowHalfX) / 2;
      //mouseY = (event.clientY - windowHalfY) / 2;

      //NEW STUFF - getting mouse coordinates as threejs world coordinates
      var vector = new THREE.Vector3();
      vector.set(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1,
        0.5);

      vector.unproject(camera);

      var dir = vector.sub(camera.position).normalize();
      var distance = -camera.position.z / dir.z;

      position3d = camera.position.clone().add(dir.multiplyScalar(distance));

    }

    function onDocumentMouseClick(event) {
      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;
      mouseX = (event.clientX - windowHalfX) / 2;
      mouseY = (event.clientY - windowHalfY) / 2;

    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }


    // add controls to the screen
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.rotateSpeed = 1.5;
    //controls.autoRotate = true;
    controls.autoRotateSpeed = 5.5;
    controls.addEventListener('change', render);

    for (var i = 0; i < 7; i++) {
      controls.enablePan = new THREE.Vector3(1, 0, 0);
      controls.enablePan = new THREE.Vector3(0, 1, 0);
    }

    var clock = new THREE.Clock;

    animate();

    function animate() {
      requestAnimationFrame(animate);
      render();
      controls.update();
      stats.update();
    }

    var startTime;
    var posX = 0;
    var maxPosX = 100; 
    var posY = 0;
    var maxPosY = 100; 

    function render() {
      var time = performance.now() * 0.0005;
      shaderMaterial.uniforms.time.value = time;

      var time_waves = performance.now() * 0.005;

      shaderMaterial_Waves.uniforms.time.value = time_waves;
      //shaderMaterial_Waves.uniforms.time.value = performance.now() / 500;
      //shaderMaterial_Waves.uniforms.x_coord.value = mouseX;
      //shaderMaterial_Waves.uniforms.y_coord.value = -mouseY;

      if (performance.now() % 1000) {

        shaderMaterial_Waves.uniforms.x_coord.value = posX + time * 10;
        line.position.x = posX + time * 10;
        dummySphere.position.x = posX + time * 10;
      }

      var clamped = Math.abs(Math.sin(time * 2.1) + Math.cos(time * 3.2) + Math.sin(time * 4.3));
      //var clamped = Math.sin(time) + Math.cos(time) + 2.5;
      //shaderMaterial_Waves.uniforms.magnitude.value = clamped;
      //shaderMaterial_Waves.uniforms.size.value = clamped;


      time = time / 20;

      shaderMaterial_ScreenShader.uniforms.angle.value = time;
      shaderMaterial_ScreenShader.uniforms.scale.value = time/10;


      var scaledTime = Math.sin(time) + 1.5; // zhis i found on the 'internet'
      var scaledTime_new = Math.sin(time * 2.1) + Math.cos(time * 3.2) + Math.sin(time * 4.3);
      //cube.scale.z = scaledTime_new;

      //camera.rotation.x += clock.getDelta();
      //camera.rotation.y += clock.getDelta();

      //cube.rotation.x += clock.getDelta() * 1.1;
      //cube.rotation.y += clock.getDelta() * 1.1;

      renderer.render(scene, camera);
    }
      
      
		</script>
	</body>
</html>